\section{Introduction}
Realistic and responsive character animation is important for establishing immersion in computer games. The complexity of human movement makes it difficult to construct such an experience by hand. Instead we record reference data using motion capture, and construct animation synthesizer that stitch clips together, sample statistical models of the data, or learn control policies for physical models. 






Both research and industry communities p
Character animation for computer games has embraced a data driven approach in both industry [ref] and research communities [ref]. Animation synthesizers or control policies  



Computer games are growing. Both in scope and ambition. Virtual worlds are becoming larger and contain increasingly complex and dynamic interactions between the characters and the environment. Multiplayer game play is most commonly the norm, and requires that the internal state of the rapidly changing game world can be reliable passed around and kept synchronized between players around the world. To manage the complexity of interaction of the full game world, individual game components are usually treated as abstract models, that should be easy to reason about, to update and keep synchronised. Then as a next step more fine grained models or simply visual fidelity is added on top. 

While it has proven extremely difficult to synthesize dynamic animations of human characters, the challenge is only greater in the context of modern game production. A common approach is to split the animation system into a abstract movement model, which produces the overall state of the game characters, and an animation system which generates animations that realistically and closely follow the path of the movement model. Introduced in 2015 Motion Matching has been adopted by many studios \kenny{as evidenced by games such ass XX, YY, ZZ}. At its core, the system stitches animations streams together by continually transitioning between frames in a large database of animation clips. The transitions are determined by finding the best matches to an external requirement which is naturally provided by the movement model. Motion matching excels when the animation database has a substantial coverage allowing the system to generate a full range of animations that are still close to the ground truth \kenny{Can we add some cites for this claim? Or we can rephrase it as: "In our experience Motion Matching excels...."}. 

Conceptually the movement model provides a control signal into the motion database. To keep synthesized animation realistic and fluent, it is critical that this control signal is reproducible in the database. In practice this is often not the case, and the issue is addressed by manually tweaking all exposed parameters in the pipeline. Most importantly weighted heuristics are added to the motion matching system, animation trajectories are manually edited and the movement model is set to reproduce the main movement modes present in the animations. To our best knowledge the process of tweaking poses is the biggest challenge to the practical use of motion matching.

In this paper we formulate the synchronization of the motion matching system, an animation database and movement model as an ill posed optimization procedure. We suggest a number of regularization steps, arriving at a solution that enables us to use unstructured animations for motion matching under movement model control while preserving fidelity in the database. The regularization procedure has two steps, where we first identify main modes in the animation database, and then distribute a sparse user control along all animation in the database. Manual edits to the animations is replaced by a warping system, allowing us to optimize against a wider range of valid input animations. Finally an optimization procedure is applied to the partially constrained movement model and animations to arrive at a configuration of the entire system.

Our contribution is a conceptual formulation of the movement model, the regularization steps required to run the optimization procedure and the [something] required to make optimization work nicely.
